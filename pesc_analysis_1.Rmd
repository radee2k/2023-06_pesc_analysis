---
title: "06-23_pesc_ev_analysis"
output: github_document
  # html_document:
  #   theme:
  #     bg: "#444444"
  #     fg: "#d6d6d6"
    
date: '2023-06-22'
---

<body style="background-color:FloralWhite;">

This script identifies lineages of EVs among cells from pleural effusion samples.


___

# Prepare the workign enviornment:

-   install and load packages
-   set %notin% and %notlike%
    -   set ggplot's theme
-   set the working directory
-   set a plan for multithreading

```{r setup, message=FALSE, warning=FALSE}
# install.packages("Seurat")
# install.packages("remotes")
# BiocManager::install(version = '3.16')
# BiocManager::install("glmGamPoi")
# remotes::install_github("stephenturner/annotables")
# install.packages("glmGamPoi")
# BiocManager::install("DESeq2")


library(Seurat)
library(dplyr)
library(data.table)
library(Matrix)
library(ggplot2)
library(scales) # to better customize Seurat's plots
library(ggpubr)
library(ggrepel)
library(future)
library(annotables) # for turning Ensembl ID to symbol
library(sctransform) # for normalization  
library(glmGamPoi) # for SCTransform
# library(svglite) # for vectorized, lightweight plotting
library(systemfonts) # to set the font for svg outputs
library(DESeq2)

"%notin%" <- Negate("%in%")
"%notlike%" <- Negate("%like%")


# set the theme for plotting (Seurat uses ggplot's themes)
theme_set(new = theme_classic())
theme_update(
  axis.text.x = element_text(vjust = 0.5),
  strip.background = element_rect(fill = '#FFFFFF'),
  plot.title = element_text(hjust = 0.5, size = 25),
  axis.title = element_text(size = 23),
  axis.text = element_text(size = 20),
  legend.text = element_text(size = 18),
  legend.key.size = unit(2, 'line'),
  legend.title = element_text(size = 20)
  # text = element_text(family= "mono")
)

# That's not necessary (rmarkdown sets its directory as the one the .Rmd file is in.)
wd <- "/disk2/user/radgro/projects/2023-06_pesc_analysis"
knitr::opts_knit$set(root.dir = wd)



fonts <- list(
  mono = "Consolas",
  sans = "Lato"
)

# set svglite as a default for all the plots
# knitr::opts_chunk$set(knitr.chunk.dev = 'svglite')
# knitr::opts_chunk$set(dev = 'svglite', system_fonts = fonts)
knitr::opts_chunk$set(dev = 'svglite', dev.args = list(system_fonts = fonts),
                      cache = T, cache.path = "pesc_analysis_1_cache/gfm/") # cache of a github_document doesn't work if the path to the gfm folder is not provided!!!


# plan("multicore", workers = 8) # Not allowed on the server
# plan()

```

## Load and prepare the data and metadata.

```{r Load and prepare the data, cache=TRUE}
# for EVs
d_dc <- as.sparse(read.csv("data/DC_matrix.txt", sep = "\t"))

# for cells
d_c <- as.sparse(read.csv("data/PEsc_matrix.txt", sep = "\t"))

# Gene names
gt <- fread("data/genes_title.txt", sep = "\t")

# get gene symbols from annotables
gt_s <- setDT(grch38[, c("ensgene", "symbol")])
colnames(gt_s)[1] <- "Geneid"
```

Join gene names with gene symbols and change symbols for Geneids when the grch38 doesn't include any particular ID, mult set to 'first', to exclude duplicates/synonyms.

```{r }
gt_join <- gt_s[gt, on = .(Geneid), mult = 'first'][symbol %in% NA | symbol == "", symbol := Geneid]
gt_sym <- gt_join[, symbol]
```

```{r, eval = FALSE}
gt_mito <- readLines("code_for_daniel/human_mitochondrial_genes_list.txt")[-1] # Could be used for Daniel's approach
gt_join[Geneid %in% gt_mito] # same genes are mitochondrial here and in Daniel's table - all is fine
```

Insert joined gene names and symbols into datasets.

```{r }
rownames(d_c) <- gt_sym
rownames(d_dc) <- gt_sym

rm(list = c("gt", "gt_s", "gt_sym"))
```

# QC and filtering of cells.

```{r create_seurat_objects, cache=TRUE}
ds_c <- CreateSeuratObject(count = d_c, min.cells = 0, min.features = 1, project = "cells")
rm(d_c)
suppressMessages(gc())

ds_c <- PercentageFeatureSet(ds_c, pattern = "^MT-", col.name = "percent_mt")
ds_c <- PercentageFeatureSet(ds_c, "^RP[SL]", col.name = "percent_ribo")
ds_c <- PercentageFeatureSet(ds_c, "^HB[^(P)]", col.name = "percent_hb")
ds_c <- PercentageFeatureSet(ds_c, "PECAM1|PF4", col.name = "percent_plat")

```

## Plotting

### Main QC plots

```{r Main QC plots, cache=TRUE, fig.width=15, fig.height=25}
VlnPlot(ds_c, features = c('nCount_RNA','nFeature_RNA', 'percent_mt', 'percent_hb', "percent_ribo", "percent_plat"), pt.size = 1.3, ncol = 1) +  NoLegend()
```


### UMI-gene count correlation

```{r, cache=TRUE}
FeatureScatter(ds_c, "nCount_RNA", "nFeature_RNA", pt.size = 1, plot.cor = T) + scale_x_continuous(labels = scales::scientific) + NoLegend()
```

### Hemoglobin content
```{r hemoglobin_content_cells, fig.width=10, fig.height=8, cache = T}

c_hemo <- ds_c[[c("orig.ident", "nFeature_RNA", "percent_hb")]]

ggplot(c_hemo) +
  geom_jitter(aes(x = orig.ident, y = nFeature_RNA, size = percent_hb, color = percent_hb)) +
  scale_color_gradient2(midpoint = 30, mid = "orange", low="blue", high="red", ) +
  theme(axis.text.x = element_text(angle = 50)) +
  geom_hline(yintercept = 500)

rm(c_hemo)
```


___
## Filtering 

How many cells have more than 800 RNAs or more than 1000 RNAs and genes found.
```{r cache=TRUE}
length(WhichCells(ds_c, expression = nCount_RNA > 800))
length(WhichCells(ds_c, expression = nCount_RNA > 800 & nFeature_RNA > 500 & nCount_RNA > 1000 & nFeature_RNA > 600 & percent_mt < 25 & percent_ribo > 1.5
                & percent_hb < 1))
```

Filter out cells that have \<=800 features and 500 UMIs (subsetting on the percentages of different transcript types can be done later).

The percent of ribosomal genes might be low due to low transcriptional activity of the cells (5%, which was a threshold used before, removes too many cells).

```{r subset cells, cache = T}
ds_cf <- subset(x = ds_c, subset = nCount_RNA > 1000 & nFeature_RNA > 600 & percent_mt < 20 & percent_ribo > 1.5
                & percent_hb < 1)
rm(ds_c)
suppressMessages(gc())
```

### Find which genes contribute to the nCount_RNA the most

```{r most_expressed_cells_filtered, fig.width=10, cache = T}
counts_cells <- ds_cf@assays$RNA@counts
counts_cells <- Matrix::t(Matrix::t(counts_cells)/Matrix::colSums(counts_cells)) * 100

most_expr_cells <- order(apply(counts_cells, 1, median), decreasing = T)[20:1]
most_expr_counts_cells <- as.matrix(t(counts_cells[most_expr_cells,]))

rm(list = c("counts_cells", "most_expressed_cells"))

par(mar=c(5,10,1,1))
boxplot(most_expr_counts_cells, cex = 1, las = 1, xlab = "% total count per cell",
        col = (scales::hue_pal())(20)[20:1], horizontal = TRUE)

```

### QC plotting of filtered reads

```{r qc_plots_cells_filtered, fig.width=10, cache = T}
VlnPlot(ds_cf, features = c('nFeature_RNA','nCount_RNA'), log = T) ## UGLY
VlnPlot(ds_cf, features = c('percent_mt', "percent_ribo"))
```

### QC plotting of filtered reads with ggplot

```{r qc_plots_cells_filtered_ggplot, fig.width= 15, fig.height=5, cache = T}
p1 <- ggplot(as.data.table(ds_cf$nFeature_RNA)) +
  geom_violin(aes(x = "", y = V1)) +
  geom_jitter(aes(x = "", y = V1), size = .9, alpha = .4) + 
  scale_y_log10() +
  ggtitle('Genes') +
  theme(plot.title = element_text(size = 18)) +
  xlab("") +
  ylab("count")

p2 <- ggplot(as.data.table(ds_cf$nCount_RNA)) +
  geom_violin(aes(x = "", y = V1)) +
  geom_jitter(aes(x = "", y = V1), size = .9, alpha = .4) + 
  scale_y_log10() +
  ggtitle('RNAs') +
  theme(plot.title = element_text(size = 18)) +
  xlab("") +
  ylab("")

p3 <- ggplot(as.data.table(ds_cf$percent_mt)) +
  geom_violin(aes(x = "", y = V1)) +
  geom_jitter(aes(x = "", y = V1), size = .9, alpha = .4) + 
  ggtitle('Percent of\nmitochondrial') +
  theme(plot.title = element_text(size = 18)) +
  xlab("") +
  ylab("percent")

p4 <- ggplot(as.data.table(ds_cf$percent_ribo)) +
  geom_violin(aes(x = "", y = V1)) +
  geom_jitter(aes(x = "", y = V1), size = .9, alpha = .4) + 
  ggtitle('Percent of\nribosomal') +
  theme(plot.title = element_text(size = 18)) +
  xlab("") +
  ylab("")

p5 <- ggplot(as.data.table(ds_cf$percent_hb)) +
  geom_violin(aes(x = "", y = V1)) +
  geom_jitter(aes(x = "", y = V1), size = .9, alpha = .4) + 
  ggtitle('Percent of\nhemoglobin') +
  theme(plot.title = element_text(size = 18)) +
  xlab("") +
  ylab("")

p6 <- ggplot(as.data.table(ds_cf$percent_plat)) +
  geom_violin(aes(x = "", y = V1)) +
  geom_jitter(aes(x = "", y = V1), size = .9, alpha = .4) + 
  ggtitle('Percent of\nplatelet') +
  theme(plot.title = element_text(size = 18)) +
  xlab("") +
  ylab("")


ggarrange(p1, p2, p3, p4, p5, p6, nrow = 1)

# ggarrange(ggarrange(p1, p2), 
          # ggarrange(p3, p4, p5, p6, ncol = 2, nrow = 2, widths = 2),
          # nrow = 2)

#ggsave("qc_violins_filt_p3.png", qcplots, device = 'png', dpi = "retina", width = 21, height = 12, bg = "white")
```



### UMI-gene count correlation

```{r, cache=TRUE, fig.height=5, cache = T}
FeatureScatter(ds_cf, "nCount_RNA", "nFeature_RNA", pt.size = 1, plot.cor = T) + scale_x_continuous(labels = scales::scientific) + NoLegend()
```



### Hemoglobin content
```{r hemoglobin_content_cells_filtered, fig.width=10, fig.height=8}

cf_hemo <- ds_cf[[c("orig.ident", "nFeature_RNA", "percent_hb")]]

ggplot(cf_hemo) +
  geom_jitter(aes(x = orig.ident, y = nFeature_RNA, size = percent_hb, color = percent_hb)) +
  scale_color_gradient2(midpoint = .5, mid = "orange", low="blue", high="red", ) +
  theme(axis.text.x = element_text(angle = 50))

rm(cf_hemo)
```


___
# QC and filtering of EVs.

```{r, cache = T}
ds_dc <- CreateSeuratObject(count = d_dc, min.cells = 0, min.features = 1, project = "ev")
rm(d_dc)
suppressMessages(gc())


ds_dc <- PercentageFeatureSet(ds_dc, pattern = "^MT-", col.name = "percent_mt")
ds_dc <- PercentageFeatureSet(ds_dc, "^RP[SL]", col.name = "percent_ribo")
ds_dc <- PercentageFeatureSet(ds_dc, "^HB[^(P)]", col.name = "percent_hb")
ds_dc <- PercentageFeatureSet(ds_dc, "PECAM1|PF4", col.name = "percent_plat")

```

```{r, fig.width=15, fig.height=25, cache = T}
VlnPlot(ds_dc, features = c('nCount_RNA','nFeature_RNA', 'percent_mt', 'percent_hb', "percent_ribo", "percent_plat"), pt.size = 1.3, ncol = 1) +  NoLegend()
```

### Other qc plots 

```{r, fig.width=10, fig.height=5, cache = T}
FeatureScatter(ds_dc, "nCount_RNA", "nFeature_RNA", pt.size = 1, plot.cor = T) + 
  scale_x_continuous(labels = scales::scientific) + 
  scale_y_continuous(labels = scales::scientific)
```
___
## Filtering 

```{r, cache = T}
length(WhichCells(ds_dc, expression = nFeature_RNA > 100))
length(WhichCells(ds_dc, expression = nFeature_RNA > 100 & nCount_RNA > 500))

# most common genes for cells:
sort(Matrix::rowSums(ds_cf), decreasing = T)[1:10]

# most common genes for EVs
sort(Matrix::rowSums(ds_dc), decreasing = T)[1:10]

```

## filter out EV samples that have x features and UMIs

```{r, cache = T}
ds_dcf <- subset(x = ds_dc, subset = nCount_RNA > 500 & nFeature_RNA > 100 & percent_mt < 90 & percent_ribo < 90)
rm(ds_dc)
suppressMessages(gc())
```

## Find which genes contribute to the nCount_RNA the most


```{r most_expressed_evs_filtered, fig.width=10, cache = T}
C <- ds_dcf@assays$RNA@counts
C <- Matrix::t(Matrix::t(C)/Matrix::colSums(C)) * 100
most_expressed <- order(apply(C, 1, median), decreasing = T)[20:1]

par(mar=c(5,10,1,1))
boxplot(as.matrix(t(C[most_expressed,])), cex = 1, las = 1, xlab = "% total count per fraction",
        col = (scales::hue_pal())(20)[20:1], horizontal = TRUE)

```




___
## QC plotting of filtered reads 

**Logarithmic axes.**

```{r, fig.width=10, cache = T}
VlnPlot(ds_dcf, features = 'nFeature_RNA', pt.size = 1.3, log = T) +  NoLegend()
VlnPlot(ds_dcf, features = 'nCount_RNA', pt.size = 1.3, log = T) +  NoLegend()
```



___
### Other qc plots 

```{r, fig.width=10, fig.height=5, cache = T}
FeatureScatter(ds_dcf, "nCount_RNA", "nFeature_RNA", pt.size = 1, plot.cor = T) + 
  scale_x_continuous(labels = scales::scientific) +
  scale_y_continuous(labels = scales::scientific)
```

# Ratio of well annotated genes (with symbols) to the rest

**On both graphs there're two dots per cell or EV sample - one for genes with and one for genes without a symbol.**

```{r, cache=TRUE}
ratc <- as.data.table(ds_cf@assays$RNA@counts, keep.rownames = T)
ratc <- melt(ratc, id.vars = "rn")

ratc[, "code_symb" := ifelse(rn %like% "ENSG", "ens", "symb")]
ratc <- ratc[, sum(value), by = .(variable, code_symb)]
ratc[, "ratio" := V1/sum(V1), by = .(variable)]

ratc[code_symb == "ens", mean(ratio)]

ggplot(ratc) +
  geom_point(aes(x = V1, y = ratio, color = code_symb)) +
  guides(color = guide_legend(title = "", size = 19, override.aes = list(size = 5))) +
  xlab("RNA count") +
  ylab("ratio to all genes per cell") +
  ggtitle("Ratios of RNA counts with and without a symbol - cells") +
  theme(plot.title = element_text(size = 18), axis.text = element_text(size = 15), axis.title = element_text(size = 17))

```

```{r, cache=TRUE}
ratev <- as.data.table(ds_dcf@assays$RNA@counts, keep.rownames = T)
ratev <- melt(ratev, id.vars = "rn")

ratev[, "code_symb" := ifelse(rn %like% "ENSG", "ens", "symb")]
ratev <- ratev[, sum(value), by = .(variable, code_symb)]
ratev[, "ratio" := V1/sum(V1), by = .(variable)]
ratev[code_symb == "ens", mean(ratio)]

ggplot(ratev) +
  geom_point(aes(x = V1, y = ratio, color = code_symb)) +
  guides(color = guide_legend(title = "", size = 19, override.aes = list(size = 5))) +
  xlab("RNA count") +
  ylab("ratio to all genes per EV sample") +
  ggtitle("Ratios of RNA counts with and without a symbol - EVs") +
  theme(plot.title = element_text(size = 18), axis.text = element_text(size = 15), axis.title = element_text(size = 17))

rm(list = c('ratev', 'ratc'))
suppressMessages(gc())
```
___
# Metadata 

## Cells
Assign cells to the patient, ...    

```{r, assign metadata, cache = T}
full_names <- colnames(ds_cf)
reg.pat <- regmatches(full_names, regexpr("PEsc[0-9]{1,6}", full_names))
reg.pat <- gsub("PEsc", "", reg.pat)
ds_cf@meta.data$pat <- reg.pat
```

...the replicate...

```{r, cache = T}
reg.rep <- regmatches(full_names, regexpr("PEsc[0-9]{1,6}(.|_)[0-9]", full_names))
reg.rep <- gsub("PEsc[0-9]{1,6}(.|_)", "", reg.rep)
ds_cf@meta.data$rep <- reg.rep
```

...and diagnosis and type of biopsy.

```{r, cache = T}
metd <- fread("PEpatients_sorted.csv")
metd[, c("type", "diag") := lapply(.SD, factor), .SDcols = c("type", 'diag')]
metd[, pat_numb := regmatches(metd[, pat_numb], regexpr("[0-9]{3,5}", metd[, pat_numb]))]

# replace missing type values ("") with "unknown".
metd[type == "", type := "unknown"]

patd <- as.data.table(reg.pat)
colnames(patd) <- "pat_numb"
met.full <- metd[patd, on = .(pat_numb)]


ds_cf@meta.data$type <- met.full[, type]
ds_cf@meta.data$diag <- met.full[, diag]

rm(list = c("reg.rep", "reg.pat"))
```

## EVs
Assign EVs to the fraction they're from,...

```{r, cache = T}
full_names <- colnames(ds_dcf)
reg.frac <- regmatches(full_names, regexpr("_[A-Z]{1,2}_", full_names))
reg.frac <- gsub("_", "", reg.frac)
ds_dcf@meta.data$frac <- reg.frac
```

...the patient and the type of biopsy.

```{r, cache = T}
reg.pat <- regmatches(full_names, regexpr("X[0-9]{1,6}", full_names))
reg.pat <- gsub("X", "", reg.pat)
reg.pat[reg.pat == 804] <- 604 # a patient number correction
ds_dcf@meta.data$pat <- reg.pat


patd <- as.data.table(reg.pat)
colnames(patd) <- "pat_numb"
met.full <- metd[patd, on = .(pat_numb)]

ds_dcf@meta.data$type <- met.full[, type]
ds_dcf@meta.data$diag <- met.full[, diag]
```

___
# Clustering analysis
## Cells

### Normalization, scaling and dimensionality reduction
**Normalization was done using the SC transform described here: <https://genomebiology.biomedcentral.com/articles/10.1186/s13059-019-1874-1> as it is supposed to be depth-independent, which justifies its use in Smartseq3 EV sequencing.**

**During the analysis a change in mapping occurred, without significantly affecting its overall profile, possibly due to package update.**

```{r, cache = T}
ds_cf <- SCTransform(ds_cf, vst.flavor = "v2", verbose = FALSE) %>%
  RunPCA(npcs = 30, verbose = FALSE) %>%
  RunUMAP(reduction = "pca", dims = 1:30, verbose = FALSE)
  # RunUMAP(reduction = "pca", dims = 1:30, verbose = FALSE, n.components = 2)
# table(ds_cf@meta.data[c("pat", "diag", "type")])
```

Data allows to stratify cells according to their origin and diagnosis, however different populations seem to be too mixed.

```{r, cache = T, fig.width= 15, fig.height= 10}
DimPlot(ds_cf, group.by = c("pat", "diag", "type", "rep"))
```



```{r useful obsolete chunk, fig.width= 15, fig.height= 10, eval = F, echo = F}
rep_plot <- list()

# Appending to the list doesn't work, otherwise really cool.
# for (i in unique(ds_cf$pat)) {
#   
#   print(i)
#   rep_plot_single <- paste0("rep_plot_single_", i)
#   
#   assign(rep_plot_single, DimPlot(subset(ds_cf, pat == i)) +h
#                                     labs(title = i) +
#                                     theme(plot.title = element_text(hjust = .5))
#   )
#   
#   print(rep_plot_single)
#   
#   rep_plot[i] <- get(rep_plot_single)
#   rm(list = rep_plot_single)
#   
# }


plot_data_column = function (data, column) {
    ggplot(data, aes_string(x = column)) +
        geom_histogram(fill = "lightgreen") +
        xlab(column)
}

# how to remove bad plots
# rm(list = ls()[ls() %like% "rep_plot"])

```

```{r useful obsolete chunk2, fig.width= 15, fig.height= 10, eval = F, echo = F}
rep_plot <- list()

plot_reps <- function (data, patient) {
  
  DimPlot(subset(data, pat == patient), group.by = "rep") +
    scale_x_continuous(limits = c(-18, 12)) +
    scale_y_continuous(limits = c(-12, 12)) +
    labs(title = patient) +
    theme(plot.title = element_text(hjust = .5))
  
}

rep_plot <- lapply(unique(ds_cf$pat), plot_reps, data = ds_cf)

ggarrange(plotlist  = rep_plot)
```


### PCs
**Inspect PCs - Jackstraw doesn't work with SCTransformed data.** 

```{r, cache = T, fig.width= 7, fig.height= 5, , eval = F, echo = F}
ds_cf <- JackStraw(ds_cf, num.replicate = 100) 
ds_cf <- ScoreJackStraw(ds_cf, dims = 1:20) 

JackStrawPlot(ds_cf, dims = 1:15)
```

**Elbow Plot**
Around 10 top PCAs should be enough to obtain proper clustering.
```{r, cache = T, fig.width= 7, fig.height= 5}
ElbowPlot(ds_cf)
```


### Variable features

**Top 10 most variable genes:**


|Gene|Protein|Description (from genecards)|
|------|------|------|
|COL1A1, COL1A2|Collagen 1||
|SFTPB|pulmonary-associated surfactant protein B||
|SPARC|cysteine-rich acidic matrix-associated protein|involved in extracellular matrix synthesis|
|SPP1|Secreted Phosphoprotein 1|bone-osteoclasts interaction and a cytokine that upregulates expression of interferon-gamma and interleukin-12|
|ENSG00000203396|WDR45-like pseudogene||
|TAGLN|Transgelin|calponin, a shape change and transformation sensitive actin-binding protein, early marker of smooth muscle differentiation, a tumor suppressor|
|IGFBP4|insulin-like growth factor binding protein 4|binds both insulin-like growth factors I and II and circulates in the plasma prolonging their half-life and changing interactions|
|IGF2|Insulin Like Growth Factor 2|epigenetic changes at its locus are associated with Wilms tumour, Beckwith-Wiedemann syndrome, rhabdomyosarcoma, and Silver-Russell syndrome, involved in Apoptotic Pathways in Synovial Fibroblasts|
|COL6A1|Collagen Type VI Alpha 1 Chain|its mutations result in Bethlem myopathy and Ullrich muscular dystrophy, involved in platelet-derived growth factor binding|


```{r, cache = T, fig.width= 10, fig.height= 5}
top10_c <- head(VariableFeatures(ds_cf), 10) # No need to use FindVariableFeatures, as SCTransform does that

p_var_c <- VariableFeaturePlot(ds_cf)
LabelPoints(p_var_c, points = top10_c, repel = T)
```

**Top 10 variable genes and gene and RNA counts.**
Most of the variable genes are upregulated in cells from patients 3133 and 3256.

```{r, cache = T, fig.width= 15, fig.height= 10}
FeaturePlot(ds_cf, features = c('nFeature_RNA','nCount_RNA', top10_c), pt.size = 1, reduction = 'umap', slot = "scale.data")
```

### Feature plot - Umap

**RNA and gene counts seem to not influence the clustering outcome**
```{r, cache = T, fig.width= 10, fig.height= 5}
FeaturePlot(ds_cf, features = c("nCount_RNA", "nFeature_RNA"), pt.size = 2, reduction = 'umap')
```


### Clustering 
```{r clustering_cells_umap, fig.height=10, fig.width=15, cache=TRUE}

ds_cf <- FindNeighbors(ds_cf, reduction = "umap", verbose = FALSE, dims = 1:2) %>%
  FindClusters(resolution = 0.5, verbose = FALSE)

p1 <- DimPlot(ds_cf, group.by = c("pat", "diag", "type"), pt.size = 1.5, reduction = "umap")

alpha_colors <- hue_pal()(27) #  number of colors equal to number of clusters - required to change the alpha

p2 <- DimPlot(ds_cf, pt.size = 2, label = T, cols = alpha(alpha_colors, .6), reduction = "umap") + 
  labs(title = "clusters") + 
  theme(plot.title = element_text(hjust = .5))


p1 + p2

```

**If clusters are found using PCA:**
```{r clustering_cells_pca, cache = T, fig.width= 15, fig.height= 10}
ds_cf <- FindNeighbors(ds_cf, reduction = "pca", dims = 1:10, verbose = FALSE) %>%
  FindClusters(resolution = 0.7, verbose = FALSE)

p1 <- DimPlot(ds_cf, group.by = c("pat", "diag", "type"), pt.size = 1.5, reduction = "umap")


alpha_colors <- hue_pal()(14) #  number of colors equal to number of clusters - required to change the alpha

p2 <- DimPlot(ds_cf, pt.size = 2, label = T, cols = alpha(alpha_colors, .6), reduction = "umap") + 
  labs(title = "clusters") + 
  theme(plot.title = element_text(hjust = .5))


p1 + p2

```




### Post-clustering QC

**Data was further explored to exclude possible confounding effects in data quality:**

#### Inter-replicate variance
```{r, check inter-replicate variance, cache = T, fig.width= 15, fig.height= 5}
p1 <- DimPlot(ds_cf, split.by = "pat", group.by = "rep", reduction = "pca")
p2 <- DimPlot(ds_cf, split.by = "pat", group.by = "rep")

p1 + p2
```

#### Heatmaps of genes with highest PC scores.
##### All patients.
```{r dim_heatmap_cells, cache = T, fig.width= 15, fig.height= 10}

dim_plot_pca <- DimHeatmap(ds_cf, dims = 1:6, balanced = TRUE, reduction = "pca", fast = F, combine = F)

for (i in 1:length(dim_plot_pca)) {
  
  pc <- paste0("PC_", i)
  
  dim_plot_pca[[i]] <- dim_plot_pca[[i]] + theme(legend.position = "none", axis.text.y = element_text(size = 11),
          plot.title = element_text(size = 14)) +
          ggtitle(label = pc)
  
}

ggarrange(plotlist = dim_plot_pca, align = "v", common.legend = T, legend = "right")

```

##### PC1 of each patient.
```{r dim_heatmap_cells_patients, cache = T, fig.width= 15, fig.height= 14}
plot_pat_dim_heat <- function (data, patient) {

  DimHeatmap(subset(data, subset = pat == patient), nfeatures = 30,  dims = 1, balanced = TRUE, fast = F) +
    theme(legend.position = "none", axis.text.y = element_text(size = 11),
          plot.title = element_text(size = 14)) +
    ggtitle(label = patient)

  }

pat_dim_heat <- lapply(unique(ds_cf$pat), plot_pat_dim_heat, data = ds_cf)
ggarrange(plotlist  = pat_dim_heat, common.legend = T, legend = "right")


```



#### Patients 3133 and 3256.
**Cells of patients 3133, 3256 have nearly identical expression profile despite different diagnoses - Both patients will be removed from the analysis.**
```{r dim_heatmap_cells_3133_3256, cache = T, fig.width= 15, fig.height= 10}

list_heatmaps <- DimHeatmap(subset(ds_cf, subset = pat %in% c(3133, 3256)), dims = 1:6, balanced = TRUE, fast = F, combine = F) 
  

plot_dim_heat <- function (x) {
  
  heatmap_x <- list_heatmaps[[x]] + 
    ggtitle(paste0("PC_", x)) +
    theme(axis.text.y = element_text(size = 12),
          plot.title = element_text(size = 14),
          legend.position = "none")
  
  return(heatmap_x)
}

heatmaps <- lapply(1:length(list_heatmaps), plot_dim_heat)

ggarrange(plotlist = heatmaps, align = "v", common.legend = T, legend = "right")

```

#### All patients - most expressed and most variable genes.

```{r dim_heatmap_cells_most_expr_most_var, cache = T, fig.width= 15, fig.height= 8}

list_heatmap <- names(sort(colSums(most_expr_counts_cells), decreasing = T))

p1 <- DoHeatmap(ds_cf, features = list_heatmap, group.by = "pat", slot = 'counts') + 
    guides(color = "none") +
    theme(axis.text.y = element_text(size = 11), title = element_text(size = 13)) +
    ggtitle(label = "top 10 most expressed")
p2 <- DoHeatmap(ds_cf, features = top10_c, group.by = "pat", slot = "scale.data") + 
    guides(color = "none") +
    theme(axis.text.y = element_text(size = 11), title = element_text(size = 13)) +
    ggtitle(label = "top 10 most variable (scaled data)")

p1 + p2
```



```{r cell_selector, eval = F}
DimPlot(ds_cf, group.by = c("pat", "diag", "type", "rep"))

```


## Cells without patients 3133 and 3256.
### PCA
```{r subset the dataset, cache = T}
# Subset the dataset
pat2 <- unique(ds_cf$pat)
pat2 <- pat2[1:6]

ds_cf2 <- subset(ds_cf, subset = pat %in% pat2)

ds_cf2 <- SCTransform(ds_cf2, vst.flavor = "v2", verbose = FALSE) %>%
  RunPCA(npcs = 30, verbose = FALSE) %>%
  RunUMAP(reduction = "pca", dims = 1:15, verbose = FALSE)

```

### Elbow Plot

Around 15 top PCAs should be enough to obtain proper clustering.
```{r, cache = T, fig.width= 7, fig.height= 5}
ElbowPlot(ds_cf2, ndims = 30)
```


**10 PCAs was allowing to obtain lesser separation of cells with regard to replicates, however, 15 provided with better resolution of clusters.**


### Umap
```{r, cache = T, fig.width= 15, fig.height= 10}
DimPlot(ds_cf2, group.by = c("pat", "diag", "type", "rep"))
```


### Correlation of metadata and PCs
```{r correlation of PCs with metadata, fig.width= 10, cache = T}
# adapted from https://jdblischak.github.io/singlecell-qtl/pca-variable.html
get_r2 <- function(x, y) {
  stopifnot(length(x) == length(y))
  model <- lm(y ~ x)
  stats <- summary(model)
  return(stats$adj.r.squared)
}
covariates <- ds_cf2@meta.data

pcs <- ds_cf2@reductions$pca@cell.embeddings[,1:30]

r2 <- matrix(NA, nrow = ncol(covariates), ncol = ncol(pcs),
             dimnames = list(colnames(covariates), colnames(pcs)))
for (cov in colnames(covariates)) {
  for (pc in colnames(pcs)) {
    r2[cov, pc] <- get_r2(covariates[, cov], pcs[, pc])
  }
}

heatmap(r2, cexCol = 1)
```

### PCs
```{r, cache = T, fig.width= 15, fig.height= 10}
DimPlot(ds_cf2, group.by = c("pat", "diag", "type", "rep"), reduction = "pca")
```





### Inter-replicate variance
```{r, check inter-replicate variance2, cache = T, fig.width= 15, fig.height= 5}
p1 <- DimPlot(ds_cf2, split.by = "pat", group.by = "rep", reduction = "pca")
p2 <- DimPlot(ds_cf2, split.by = "pat", group.by = "rep")

p1 + p2
```






### Heatmaps of genes with highest PC scores.
#### First 20 PCs of all patients
```{r dim_heatmap_cells_2, cache = T, fig.width= 15, fig.height= 25}
dim_plot_pca <- DimHeatmap(ds_cf2, dims = 1:20, nfeatures = 20, balanced = TRUE, fast = F, combine = F)

for (i in 1:length(dim_plot_pca)) {
  
  pc <- paste0("PC_", i)
  
  dim_plot_pca[[i]] <- dim_plot_pca[[i]] + theme(legend.position = "none", axis.text.y = element_text(size = 11),
          plot.title = element_text(size = 14)) +
          ggtitle(label = pc)
  
}

ggarrange(plotlist = dim_plot_pca, align = "v", ncol = 3, nrow = 7, common.legend = T, legend = "right")

```

#### PC1 of each patient.
```{r dim_heatmap_cells_patients_2, cache = T, fig.width= 15, fig.height= 12}
plot_pat_dim_heat <- function (data, patient) {

  DimHeatmap(subset(data, subset = pat == patient), nfeatures = 30,  dims = 1, balanced = TRUE, fast = F) +
    theme(legend.position = "none", axis.text.y = element_text(size = 11),
          plot.title = element_text(size = 14)) +
    ggtitle(label = patient)

  }

pat_dim_heat <- lapply(unique(ds_cf2$pat), plot_pat_dim_heat, data = ds_cf)
ggarrange(plotlist  = pat_dim_heat, align = "v", common.legend = T, legend = "right")


```




### Variable features

Top 22 variable genes are annotated.

```{r, cache = T, fig.width= 10, fig.height= 5}
top22_c <- head(VariableFeatures(ds_cf2), 22)

p_var_c <- VariableFeaturePlot(ds_cf2)
LabelPoints(p_var_c, points = top22_c, repel = T, xnudge = .2, ynudge = 1, max.overlaps = 20)
```

Top 22 variable genes and 

```{r, cache = T, fig.width= 15, fig.height= 15}
FeaturePlot(ds_cf2, features = c('nFeature_RNA','nCount_RNA', top22_c), pt.size = 1, reduction = 'umap', slot = "scale.data") & 
  theme(plot.title = element_text(size = 12),
        legend.text = element_text(size = 9),
        axis.title = element_text(size = 10))
```

```{r annotate most variable genes}
top22_c_an <- data.table(symbol = top22_c)
gt_s_an <- setDT(grch38[c("symbol", "description")])

top22_c_an <- gt_s_an[top22_c_an, on = .(symbol), mult = 'first']

knitr::kable(top22_c_an, caption = "**Top 22 most variable genes**")
```


### Clustering

```{r finding clusters cells2, cache=T, fig.width= 15, fig.height=8}

ds_cf2 <- FindNeighbors(ds_cf2, verbose = FALSE, dims = 1:15) %>%
  FindClusters(resolution = 0.5, verbose = FALSE)

p1 <- DimPlot(ds_cf2, group.by = c("pat", "diag", "type", "rep"), pt.size = 1.5, reduction = "umap")


alpha_colors <- hue_pal()(10) #  number of colors equal to number of clusters - required to change the alpha

p2 <- DimPlot(ds_cf2, pt.size = 2, label = T, cols = alpha(alpha_colors, .6), reduction = "umap") + 
  labs(title = "clusters") + 
  theme(plot.title = element_text(hjust = .5))


ggarrange(p1, p2, widths = c(3, 2))

```

## DE analysis
```{r cells2 DEseq, cache = T}
c_markers <- FindAllMarkers(ds_cf2, assay = "RNA", test.use = "DESeq2", min.pct = 0.4, verbose = F) # minimal feature frequency of 40%

for(i in levels(c_markers$cluster)) {print(head(c_markers[c_markers$cluster == i,], 10))}
```

Plot most differentially expressed genes
```{r most_diff_bar, fig.width=15, fig.height=10}
setDT(c_markers)
highest_de <- c_markers[order(avg_log2FC, decreasing = T), .SD[1:5] ,by = cluster][p_val < 5e-2][order(cluster)]
lowest_de <- c_markers[order(avg_log2FC), .SD[1:5] ,by = cluster][p_val < 5e-2][order(cluster)]

most_diff_c <- merge(highest_de, lowest_de, all = T)

ggplot(c_markers) +
  geom_jitter(aes(x = cluster, y = avg_log2FC, color = -log10(p_val)), width = .2) +
  geom_hline(yintercept = 0) +
  geom_text_repel(most_diff_c, mapping = aes(x = cluster, y = avg_log2FC, label = gene),
                  size = 4.5, color = "red", fontface = "bold") +
  scale_color_continuous(trans = "log", breaks = c(1, 10, 50, 125))
  
```


```{r cluster_heatmap, cache = t, fig.width= 15, fig.height= 15}
highest_de <- c_markers[order(avg_log2FC, decreasing = T), .SD[1:10] ,by = cluster][p_val < 5e-2][order(cluster)]


DoHeatmap(ds_cf2, group.by = "seurat_clusters", features = highest_de$gene) + NoLegend()

```



```{r }
ds_cf2 <- PrepSCTFindMarkers(ds_cf2)

aggr_exp <- Matrix::rowSums(ds_cf@assays$SCT)
hist(aggr_exp[aggr_exp > 50], breaks = 500)
ggplot(as.data.table(aggr_exp)) +
  geom_histogram()
```



# REST

```{r }
## EVs

ds_dcf <- SCTransform(ds_dcf, vst.flavor = "v2", verbose = FALSE) %>%
RunPCA(npcs = 30, verbose = FALSE) %>%
RunUMAP(reduction = "pca", dims = 1:30, verbose = FALSE)

DimPlot(ds_dcf, group.by = "pat", pt.size = 2)
DimPlot(ds_dcf, group.by = "frac", pt.size = 2)
DimPlot(ds_dcf, group.by = "diag", pt.size = 2)
DimPlot(ds_dcf, group.by = "type", pt.size = 2)
DimPlot(ds_dcf, group.by = c("frac", "pat", "diag", "type"), pt.size = 2)


FeaturePlot(ds_dcf, features = c("nCount_RNA", "nFeature_RNA"), pt.size = 2, reduction = 'umap')
ElbowPlot(ds_dcf, ndims = 30)


top12 <- head(VariableFeatures(ds_dcf), 12)
plot1 <- VariableFeaturePlot(ds_dcf)
plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)
FeaturePlot(ds_dcf, features = top12, pt.size = 2, reduction = 'umap')
```

histograms and violinplots of overall expression of genes

```{r }


aggr_exp <- Matrix::rowSums(ds_dcf@assays$SCT)
hist(aggr_exp[aggr_exp > 50], breaks = 500)

frac_diff <-VlnPlot(ds_dcf, features = c('nFeature_RNA','nCount_RNA'), group.by = "frac", log = T)
ggsave("frac_diff_counts.png", frac_diff, device = 'png', dpi = "retina", width = 15, height = 12, bg = "white")
```

## Further EV clustering ----

```{r }
wd2 <- "~/OneDrive - Karolinska Institutet/Dokument/nord_lab/seq/0423_pesc/plots/"
setwd(wd2)
save.image("../pesc_analysis.RData")
```

without FT

```{r }
ds_dcf1 <- subset(ds_dcf, subset = frac %notin% "FT") %>%
  SCTransform(vst.flavor = "v2", verbose = FALSE) %>%
  RunPCA(npcs = 30, verbose = FALSE) %>%
  RunUMAP(reduction = "pca", dims = 1:30, verbose = FALSE)

umap_ftless <- DimPlot(ds_dcf1, group.by = c("frac", "pat", "diag", "type"), pt.size = 2)
ggsave("ev_umap_wo_ft.png", umap_ftless, device = 'png', dpi = "retina", width = 15, height = 12, bg = "white")

top10 <- head(VariableFeatures(ds_dcf1), 10)
f_umap_ftless <- FeaturePlot(ds_dcf1, features = c('nFeature_RNA','nCount_RNA', top10), pt.size = 2, reduction = 'umap', ncol = 4)
ggsave("ev_umap_feat_wo_ft.png", f_umap_ftless, device = 'png', dpi = "retina", width = 15, height = 12, bg = "white")
```





```{r}
knitr::knit_exit()
```





without FT & cells

```{r }
ds_dcf2 <- subset(ds_dcf, subset = frac %notin% c("FT", "C")) %>%
  SCTransform(vst.flavor = "v2", verbose = FALSE) %>%
  RunPCA(npcs = 30, verbose = FALSE) %>%
  RunUMAP(reduction = "pca", dims = 1:30, verbose = FALSE)

umap_ftcless <- DimPlot(ds_dcf2, group.by = c("frac", "pat", "diag", "type"), 
                        pt.size = 2)
ggsave("ev_umap_wo_ftc.png", umap_ftcless, device = 'png', dpi = "retina", width = 15, height = 12, bg = "white")

top10 <- head(VariableFeatures(ds_dcf2), 10)
f_umap_ftcless <- FeaturePlot(ds_dcf2, features = c('nFeature_RNA','nCount_RNA', top10), 
                              pt.size = 2, reduction = 'umap', ncol = 3)
ggsave("ev_umap_feat_wo_ftc.png", f_umap_ftcless, device = 'png', dpi = "retina", width = 15, height = 12, bg = "white")
```

without FT & cells & SP

```{r }
ds_dcf3 <- subset(ds_dcf2, subset = frac %notin% c("FT", "C", "SP")) %>%
  SCTransform(vst.flavor = "v2", verbose = FALSE) %>%
  RunPCA(npcs = 30, verbose = FALSE) %>%
  RunUMAP(reduction = "pca", dims = 1:30, verbose = FALSE)

umap_ftcspless <- DimPlot(ds_dcf3, group.by = c("frac", "pat", "diag", "type"), 
                          pt.size = 2)
ggsave("ev_umap_wo_ftcsp.png", umap_ftcspless, device = 'png', dpi = "retina", width = 15, height = 12, bg = "white")

top10 <- head(VariableFeatures(ds_dcf3), 10)
f_umap_ftcspless <- FeaturePlot(ds_dcf3, features = c('nFeature_RNA','nCount_RNA', top10), 
                                pt.size = 2, reduction = 'umap', ncol = 3)
ggsave("ev_umap_feat_wo_ftcsp.png", f_umap_ftcspless, device = 'png', dpi = "retina", width = 15, height = 12, bg = "white")
```

## Dataset integration ----

```{r }
wd3 <- "C:/Users/radgro/OneDrive - Karolinska Institutet/Dokument/nord_lab/seq/0423_pesc/plots/comb"
setwd(wd3)

ds_cf[["cev"]] <- "cell"
ds_cf[["frac"]] <- "cell"
ds_dcf3[["cev"]] <- "ev"


ds_comb_list <- list(cells = ds_cf, ev = ds_dcf3)
features <- SelectIntegrationFeatures(object.list = ds_comb_list, nfeatures = 6000)
ds_comb_list <- PrepSCTIntegration(object.list = ds_comb_list, anchor.features = features)

pe_anchors <- FindIntegrationAnchors(object.list = ds_comb_list, normalization.method = "SCT", anchor.features = features)
ds_comb <- IntegrateData(anchorset = pe_anchors, normalization.method = "SCT")


ds_comb <- SCTransform(ds_comb, vst.flavor = "v2", verbose = FALSE) %>%
  RunPCA(npcs = 30, verbose = FALSE) %>%
  RunUMAP(reduction = "pca", dims = 1:30, verbose = FALSE) %>%
  FindNeighbors(reduction = "pca", dims = 1:3, verbose = FALSE) %>%
  FindClusters(resolution = 0.7, verbose = FALSE)

ElbowPlot(ds_comb, ndims = 100)


DimPlot(ds_comb, pt.size = 1.5)
DimPlot(ds_comb, split.by = "cev")
DimPlot(ds_comb, group.by = "cev", pt.size = 2)
umap_comb <- DimPlot(ds_comb, group.by = c("cev", "frac", "diag", "seurat_clusters"), pt.size = 1.5)
```

Inspect difference between EVs distant and close to the cells

```{r }
umap_comb <- DimPlot(subset(ds_comb, seurat_clusters %in% c(6, 2, 4, 9)), 
                     group.by = c("cev", "frac", "diag", "seurat_clusters"), pt.size = 1.5)
ggsave("comb_cl2469_6k.png", umap_comb, device = 'png', dpi = "retina", width = 15, height = 12, bg = "white")

ds_comb <- PrepSCTFindMarkers(ds_comb)
```

set idents to ev frac and unsupervised cluster ds_comb$frac.cl <- paste(ds_comb$) \# not needed right now

```{r }
head(Idents(ds_comb))
ds_comb.m <- FindMarkers(ds_comb, assay = "SCT", ident.1 = 9, ident.2 = 4,
                         verbose = FALSE, recorrect_umi = FALSE)
head(ds_comb.m, 15)
de_ev1 <- rownames(head(ds_comb.m, 6))

f_de_ev1 <- FeaturePlot(ds_comb, features = de_ev1, pt.size = 1.5)
ggsave("f_de_ev1_cl94.png", f_de_ev1, device = 'png', dpi = "retina", width = 15, height = 12, bg = "white")
```

Against all other cells/evs

```{r }
ds_comb.m2 <- FindMarkers(ds_comb, assay = "SCT", ident.1 = 9,
                          verbose = FALSE, recorrect_umi = FALSE)
head(ds_comb.m2, 15)
de_ev2 <- rownames(head(ds_comb.m2, 6))

f_de_ev2 <- FeaturePlot(ds_comb, features = de_ev2, pt.size = 1.5)
ggsave("f_de_ev1_cl9all.png", f_de_ev2, device = 'png', dpi = "retina", width = 15, height = 12, bg = "white")



top10 <- head(VariableFeatures(ds_comb), 10)
f_umap_comb <- FeaturePlot(ds_comb, features = c('nFeature_RNA','nCount_RNA', top10),
                           pt.size = 1.5, reduction = 'umap', ncol = 3)

f_umap_comb <- FeaturePlot(ds_comb, features =  top10,
                           pt.size = 1.5, reduction = 'umap', ncol = 3)

f_umap_comb + DimPlot(ds_comb, pt.size = 1.5)
```

optimize clustering

```{r }
ds_comb.3 <- RunUMAP(ds_comb, reduction = "pca", dims = 1:30, verbose = FALSE) %>%
  FindNeighbors(reduction = "pca", dims = 1:3, verbose = FALSE) %>%
  FindClusters(resolution = 0.7, verbose = FALSE)

DimPlot(ds_comb.3, pt.size = 1.5)
```

Filter the cells with previously decided cutoffs ----

```{r }
apf <- subset(x = p_all, subset = nCount_RNA > 1000 & nFeature_RNA > 1000)
apf <- PercentageFeatureSet(apf, pattern = "^MT-", col.name = "percent_mt")
apf <- PercentageFeatureSet(apf, "^HB[^(P)]", col.name = "percent_hb")
apf <- PercentageFeatureSet(apf, "PECAM1|apf4", col.name = "percent_plat")
apf <- PercentageFeatureSet(apf, "^RP[SL]", col.name = "percent_ribo")
```

QC plotting of filtered reads ----

```{r }
p1 <- ggplot(as.data.table(apf$nFeature_RNA)) +
geom_violin(aes(x = "PBMC, BM", y = V1)) +
geom_jitter(aes(x = "PBMC, BM", y = V1), size = .9, alpha = .4) + 
scale_y_log10() +
ggtitle('Genes') +
xlab("") +
ylab("count")

p2 <- ggplot(as.data.table(apf$nCount_RNA)) +
geom_violin(aes(x = "PBMC, BM", y = V1)) +
geom_jitter(aes(x = "PBMC, BM", y = V1), size = .9, alpha = .4) + 
scale_y_log10() +
ggtitle('RNAs') +
xlab("") +
ylab("")

p3 <- ggplot(as.data.table(apf$percent_mt)) +
geom_violin(aes(x = "PBMC, BM", y = V1)) +
geom_jitter(aes(x = "PBMC, BM", y = V1), size = .9, alpha = .4) + 
ggtitle('Percent of mitochondrial') +
xlab("") +
ylab("percent")

p4 <- ggplot(as.data.table(apf$percent_ribo)) +
geom_violin(aes(x = "PBMC, BM", y = V1)) +
geom_jitter(aes(x = "PBMC, BM", y = V1), size = .9, alpha = .4) + 
ggtitle('Percent of ribosomal') +
xlab("") +
ylab("")

p5 <- ggplot(as.data.table(apf$percent_hb)) +
geom_violin(aes(x = "PBMC, BM", y = V1)) +
geom_jitter(aes(x = "PBMC, BM", y = V1), size = .9, alpha = .4) + 
ggtitle('Percent of hemoglobin') +
xlab("") +
ylab("")

p6 <- ggplot(as.data.table(apf$percent_plat)) +
geom_violin(aes(x = "PBMC, BM", y = V1)) +
geom_jitter(aes(x = "PBMC, BM", y = V1), size = .9, alpha = .4) + 
ggtitle('Percent of platelet') +
xlab("") +
ylab("")

qcplots <- ggarrange(p1, p2, p3, p4, p5, p6, nrow = 1)
ggsave("qc_violins_filt_1.png", qcplots, device = 'png', dpi = "retina", width = 21, height = 12, bg = "white")
```

Second filtering - ribo, mito, hem ----

```{r }
apf <- subset(x = apf, subset = nCount_RNA > 1000 & nFeature_RNA > 1000
            & percent_hb < 5 & percent_mt < 25 & percent_ribo > 5 & percent_plat < 1)
```

QC plotting of filtered reads ----

```{r }
p1 <- ggplot(as.data.table(apf$nFeature_RNA)) +
geom_violin(aes(x = "PBMC, BM", y = V1)) +
geom_jitter(aes(x = "PBMC, BM", y = V1), size = .9, alpha = .4) + 
scale_y_log10() +
ggtitle('Genes') +
xlab("") +
ylab("count")

p2 <- ggplot(as.data.table(apf$nCount_RNA)) +
geom_violin(aes(x = "PBMC, BM", y = V1)) +
geom_jitter(aes(x = "PBMC, BM", y = V1), size = .9, alpha = .4) + 
scale_y_log10() +
ggtitle('RNAs') +
xlab("") +
ylab("")

p3 <- ggplot(as.data.table(apf$percent_mt)) +
geom_violin(aes(x = "PBMC, BM", y = V1)) +
geom_jitter(aes(x = "PBMC, BM", y = V1), size = .9, alpha = .4) + 
ggtitle('Percent of mitochondrial') +
xlab("") +
ylab("percent")

p4 <- ggplot(as.data.table(apf$percent_ribo)) +
geom_violin(aes(x = "PBMC, BM", y = V1)) +
geom_jitter(aes(x = "PBMC, BM", y = V1), size = .9, alpha = .4) + 
ggtitle('Percent of ribosomal') +
xlab("") +
ylab("")

p5 <- ggplot(as.data.table(apf$percent_hb)) +
geom_violin(aes(x = "PBMC, BM", y = V1)) +
geom_jitter(aes(x = "PBMC, BM", y = V1), size = .9, alpha = .4) + 
ggtitle('Percent of hemoglobin') +
xlab("") +
ylab("")

p6 <- ggplot(as.data.table(apf$percent_plat)) +
geom_violin(aes(x = "PBMC, BM", y = V1)) +
geom_jitter(aes(x = "PBMC, BM", y = V1), size = .9, alpha = .4) + 
ggtitle('Percent of platelet') +
xlab("") +
ylab("")

qcplots <- ggarrange(p1, p2, p3, p4, p5, p6, nrow = 1)
ggsave("qc_violins_filt_2.png", qcplots, device = 'png', dpi = "retina", width = 21, height = 12, bg = "white")


feats <- c("nFeature_RNA", "nCount_RNA", "percent_mt", "percent_ribo", "percent_hb", "percent_plat")

VlnPlot(apf, group.by = "orig.ident", features = feats, pt.size = 0.1, ncol = 3) +
NoLegend()
```

RNA vs antibody filtered ----

```{r }
chk_f <- data.table(colnames(apf@assays$RNA), apf$nCount_RNA, colnames(apf@assays$ab), apf$nCount_ab, apf@active.ident)

rna_ab_f <- ggplot(chk_f[V4 < 10000]) +
geom_jitter(aes(x = V2, y = V4, color = V5),
            size = 1.5, alpha = .4,
            position = position_jitter(height = .05)) +
scale_color_manual(values = c("#ffa23e", "green")) +
xlab("RNA") +
ylab("antibody tag") +
theme(
  legend.title = element_blank()
) +
guides(color = guide_legend(override.aes = list(size = 7))) +
ggtitle('RNA read count vs antibody tag count')

ggsave("RNA_vs_ab_filt.png", rna_ab_f, device = 'png', dpi = "retina", width = 16, height = 12, bg = "white")
```

Data normalization and clustering ----

```{r }
apf <- NormalizeData(apf, normalization.method='RC', scale.factor=1e4)

apf <- FindVariableFeatures(apf, nfeatures = 10000)
length(apf@assays$RNA@var.features)

apf <- ScaleData(apf)
apf <- RunPCA(apf, verbose = T, npcs = 20)
apf <- RunUMAP(apf, dims = 1:20, verbose = T)
apf <- RunTSNE(apf)


DimPlot(apf, group.by = "orig.ident", pt.size = 2)
DimPlot(apf, group.by = "orig.ident", pt.size = 2, reduction = "pca")
DimPlot(apf, group.by = "orig.ident", pt.size = 2, reduction = "tsne")

p4f <- subset(apf, idents = "pat4")
p4f <- NormalizeData(p4f, normalization.method='RC', scale.factor=1e4)
p4f <- FindVariableFeatures(p4f, nfeatures = 10000)
length(p4f@assays$RNA@var.features)

p4f <- ScaleData(p4f)
p4f <- RunPCA(p4f, verbose = T, npcs = 30)
p4f <- RunUMAP(p4f, dims = 1:10, verbose = T, n.neighbors = 10)

DimPlot(p4f, pt.size = 2)
DimPlot(p4f, pt.size = 2, reduction = "pca")
```

Subset most highly expressed

```{r }
C <- p4f@assays$RNA@counts
C <- Matrix::t(Matrix::t(C)/Matrix::colSums(C)) * 100
below5 <- names(which(apply(C, 1, median) <= .05))

p4f <- subset(p4f, features = below5)

p4f <- FindVariableFeatures(p4f, nfeatures = 10000)
p4f <- ScaleData(p4f)
p4f <- RunPCA(p4f, verbose = T, npcs = 30)
p4f <- RunUMAP(p4f, dims = 1:10, verbose = T, n.neighbors = 10)
DimPlot(p4f, pt.size = 2)
DimPlot(p4f, pt.size = 2, reduction = "pca")
```

most expressed gene

```{r }
d <- p4f@assays$RNA@data

most <- order(apply(d, 1, median), decreasing = T)[1:20]
rownames(d)[most]



out <- p4f@assays$RNA@scale.data
out.n <- rownames(out)
```

We create the .csv file

```{r }
write.csv(out, "fisk1.csv")
write.csv(out.n, "fisk1names.csv")
```

remove outliers from the PCA plot

```{r }
outl <- p4f@reductions$pca@cell.embeddings
outl <- as.data.table(outl, keep.rownames = TRUE)

outl[order(PC_1), .(rn, PC_1, PC_2)][1:50]
```

remove outliers with PCA_1 lower than -100

```{r }
keep <- outl[PC_1 > -100, rn]
p4fp <- subset(p4f, cells = keep)

p4fp <- FindVariableFeatures(p4fp, nfeatures = 10000)
feat <- rownames(p4fp)
p4fp <- ScaleData(p4fp, features = feat)
p4fp <- RunPCA(p4fp, verbose = T, npcs = 30, features = VariableFeatures(object = p4fp))
p4fp <- RunUMAP(p4fp, dims = 1:10, verbose = T, n.neighbors = 4)
DimPlot(p4fp, pt.size = 2)
DimPlot(p4fp, pt.size = 2, reduction = "pca")

FeaturePlot(p4fp, features = c("nCount_RNA", "nFeature_RNA"), pt.size = 2, reduction = 'pca')

top10 <- head(VariableFeatures(p4fp), 10)
plot1 <- VariableFeaturePlot(p4fp)
plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)
```

Explore the dimensionality - which PCs are good

```{r }
p4fp <- JackStraw(p4fp, num.replicate = 100)
p4fp <- ScoreJackStraw(p4fp, dims = 1:20)
JackStrawPlot(p4fp, dims = 1:15)
ElbowPlot(p4fp)

p4fp <- FindNeighbors(p4fp, dims = 1:10)
p4fp <- FindClusters(p4fp, resolution = 0.5)
```

Inspect different features on a dim reduc plot:

```{r }
FeaturePlot(p4fp, features = c("percent_plat", "percent_hb", "percent_mt", "percent_ribo", "nCount_RNA", "nFeature_RNA"), pt.size = 2, ncol = 3)

save.image(file = "fiskesund_hsc_10x.RData")

p4fp <- ProjectUMAP(p4fp )
p4fp <- FindClusters(p4fp, reduction.type='pca', dims.use=1:9, resolution=c(0.6,0.7,0.8,0.9,1,0.5), print.output=0, save.SNN=TRUE)
```

